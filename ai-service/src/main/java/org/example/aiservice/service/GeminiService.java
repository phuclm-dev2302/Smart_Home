package org.example.aiservice.service;

import com.google.gson.*;
import okhttp3.*;
import org.example.aiservice.dto.PostDocument;
import org.example.aiservice.dto.PostSearchRequest;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;
import reactor.core.publisher.Mono;
import reactor.core.scheduler.Schedulers;

import java.io.IOException;
import java.util.*;
import java.util.concurrent.TimeUnit;

@Service
public class GeminiService {

    @Value("${gemini.api-key}")
    private String apiKey;

    private static final String GEMINI_URL =
            "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent";

    private final OkHttpClient client = new OkHttpClient.Builder()
            .connectTimeout(300, TimeUnit.SECONDS)
            .writeTimeout(300, TimeUnit.SECONDS)
            .readTimeout(300, TimeUnit.SECONDS)
            .build();

    private final Gson gson = new Gson();
    private final List<String> conversationHistory = new ArrayList<>();

    public void resetConversation() {
        conversationHistory.clear();
    }

    private synchronized void addToHistory(String msg) {
        conversationHistory.add(msg);
    }

    private synchronized List<Map<String, Object>> getHistoryParts() {
        List<Map<String, Object>> parts = new ArrayList<>();
        for (String msg : conversationHistory) {
            parts.add(Map.of("text", msg));
        }
        return parts;
    }

    public Mono<String> chat(String text) {
        return Mono.fromCallable(() -> {
            addToHistory(text);
            Map<String, Object> body = Map.of("contents", List.of(Map.of("parts", getHistoryParts())));
            return sendToGemini(body, true);
        }).subscribeOn(Schedulers.boundedElastic());
    }

    public Mono<String> chatSingle(String text) {
        return Mono.fromCallable(() -> {
            Map<String, Object> body = Map.of("contents", List.of(Map.of("parts", List.of(Map.of("text", text)))));
            return sendToGemini(body, false);
        }).subscribeOn(Schedulers.boundedElastic());
    }

    private String sendToGemini(Map<String, Object> body, boolean saveHistory) throws IOException {
        String json = gson.toJson(body);

        Request request = new Request.Builder()
                .url(GEMINI_URL + "?key=" + apiKey)
                .addHeader("Content-Type", "application/json")
                .post(RequestBody.create(json, MediaType.get("application/json")))
                .build();

        try (Response response = client.newCall(request).execute()) {
            if (!response.isSuccessful()) {
                throw new IOException("Request failed: " + response);
            }

            String responseBody = response.body().string();
            JsonObject jsonResponse = gson.fromJson(responseBody, JsonObject.class);

            String reply = jsonResponse.getAsJsonArray("candidates")
                    .get(0).getAsJsonObject()
                    .getAsJsonObject("content")
                    .getAsJsonArray("parts")
                    .get(0).getAsJsonObject()
                    .get("text").getAsString();

            if (saveHistory) addToHistory(reply);
            return reply;
        }
    }

    public Mono<PostSearchRequest> extractSearchRequest(String userQuery, boolean useMemory) {
        String prompt = """
        H√£y tr√≠ch xu·∫•t th√¥ng tin t·ª´ c√¢u h·ªèi sau v√† tr·∫£ v·ªÅ ƒë√∫ng ƒë·ªãnh d·∫°ng JSON v·ªõi c√°c tr∆∞·ªùng:
        city, district, postType (HOME, APARTMENT, BUSINESS_PREMISES, ACCOMMODATION),
        bedRoom, bathRoom, minPrice, maxPrice, minArea, maxArea, title, description, amenities.
        
        `amenities` l√† m·∫£ng ti·ªán √≠ch (v√≠ d·ª•: ["Wifi", "M√°y l·∫°nh"]).
        
        V√≠ d·ª•:
        {
          "city": "H·ªì Ch√≠ Minh",
          "district": "Qu·∫≠n 1",
          "postType": "APARTMENT",
          "bedRoom": 2,
          "bathRoom": null,
          "minPrice": null,
          "maxPrice": 10000000,
          "minArea": null,
          "maxArea": null,
          "title": null,
          "description": null,
          "amenities": ["Wifi", "M√°y l·∫°nh"]
        }

        ‚ùóÔ∏èY√™u c·∫ßu b·∫Øt bu·ªôc:
        - Tr·∫£ v·ªÅ **duy nh·∫•t** ƒëo·∫°n JSON nh∆∞ tr√™n.
        - ‚ùå Kh√¥ng ƒë∆∞·ª£c th√™m b·∫•t k·ª≥ m√¥ t·∫£, markdown, ```json ho·∫∑c vƒÉn b·∫£n n√†o kh√°c.

        C√¢u h·ªèi: """ + userQuery;

        Mono<String> responseMono = useMemory ? chat(prompt) : chatSingle(prompt);

        return responseMono.map(raw -> {
            String cleaned = cleanJson(raw);
            System.out.println("üß† Cleaned Gemini JSON:\n" + cleaned);

            // Ki·ªÉm tra xem th·ª±c s·ª± c√≥ ph·∫£i JSON kh√¥ng
            if (!isLikelyJson(cleaned)) {
                throw new RuntimeException("‚ùå Gemini kh√¥ng tr·∫£ v·ªÅ JSON h·ª£p l·ªá:\n" + raw);
            }

            try {
                JsonElement element = JsonParser.parseString(cleaned);
                if (!element.isJsonObject()) {
                    throw new IllegalStateException("Expected JSON object but got: " + cleaned);
                }
                return gson.fromJson(element, PostSearchRequest.class);
            } catch (JsonSyntaxException e) {
                System.err.println("‚ùå L·ªói parse JSON t·ª´ Gemini:\n" + raw);
                throw new RuntimeException("Gemini tr·∫£ v·ªÅ k·∫øt qu·∫£ kh√¥ng h·ª£p l·ªá: " + raw, e);
            }
        });
    }

    private boolean isLikelyJson(String text) {
        String trimmed = text.trim();
        return trimmed.startsWith("{") && trimmed.endsWith("}");
    }


    private String cleanJson(String raw) {
        String cleaned = raw.trim();

        if (cleaned.startsWith("```")) {
            cleaned = cleaned.replaceFirst("^```(json)?", "").trim();
        }
        if (cleaned.endsWith("```")) {
            cleaned = cleaned.substring(0, cleaned.length() - 3).trim();
        }

        int start = cleaned.indexOf('{');
        int end = cleaned.lastIndexOf('}');
        if (start >= 0 && end > start) {
            cleaned = cleaned.substring(start, end + 1);
        }

        return cleaned;
    }


    public Mono<String> summarizeSearchResult(String userQuery, List<PostDocument> results, boolean useMemory) {
        if (results == null || results.isEmpty()) {
            // Tr·∫£ v·ªÅ tr·ª±c ti·∫øp lu√¥n 1 Mono, KH√îNG c·∫ßn g·ªçi Gemini
            return Mono.just("Hi·ªán t·∫°i kh√¥ng c√≥ b√†i ƒëƒÉng n√†o ph√π h·ª£p v·ªõi nhu c·∫ßu t√¨m ki·∫øm c·ªßa b·∫°n.");
        }

        return Mono.fromCallable(() -> {
            PostDocument post = results.get(0); // b√†i ƒëƒÉng ph√π h·ª£p nh·∫•t

            String prompt = String.format("""
        D·ª±a v√†o b√†i ƒëƒÉng sau, h√£y vi·∫øt m·ªôt ƒëo·∫°n vƒÉn m√¥ t·∫£ ng·∫Øn g·ªçn, r√µ r√†ng, th√¢n thi·ªán, ph√π h·ª£p v·ªõi ng∆∞·ªùi ƒëang t√¨m nh√† cho thu√™.
        H√£y t∆∞·ªüng t∆∞·ª£ng b·∫°n l√† m·ªôt chuy√™n vi√™n t∆∞ v·∫•n nh√† ƒë·∫•t ƒëang tr·∫£ l·ªùi cho kh√°ch h√†ng. KH√îNG TR·∫¢ V·ªÄ D·∫†NG JSON. Ch·ªâ vi·∫øt m·ªôt ƒëo·∫°n vƒÉn m√¥ t·∫£...

        ‚ùóÔ∏èY√™u c·∫ßu b·∫Øt bu·ªôc:
        - Vi·∫øt **m·ªôt ƒëo·∫°n vƒÉn duy nh·∫•t**.
        - ‚ùå Kh√¥ng xu·ªëng d√≤ng, kh√¥ng markdown, kh√¥ng JSON, kh√¥ng b·∫Øt ƒë·∫ßu b·∫±ng ``` ho·∫∑c `{}`.
        - C√¢u vƒÉn ph·∫£i b·∫Øt ƒë·∫ßu b·∫±ng: **"Ch√∫ng t√¥i ƒë√£ t√¨m th·∫•y m·ªôt b√†i ƒëƒÉng ph√π h·ª£p v·ªõi nhu c·∫ßu t√¨m ki·∫øm c·ªßa b·∫°n..."**

        Th√¥ng tin b√†i ƒëƒÉng:
        - Ti√™u ƒë·ªÅ: %s
        - M√¥ t·∫£: %s
        - ƒê·ªãa ch·ªâ: %s, %s, %s, %s
        - Gi√°: %,.0f VND
        - Di·ªán t√≠ch: %.1f m¬≤
        - Ph√≤ng ng·ªß: %d
        - Ph√≤ng v·ªá sinh: %d
        - Ti·ªán √≠ch: %s
        """,
                    post.getTitle(),
                    post.getDescription(),
                    post.getAddress(), post.getWard(), post.getDistrict(), post.getCity(),
                    post.getPrice() != null ? post.getPrice() : 0,
                    post.getArea() != null ? post.getArea() : 0,
                    post.getBedRoom() != null ? post.getBedRoom() : 0,
                    post.getBathRoom() != null ? post.getBathRoom() : 0,
                    post.getAmenities() != null ? String.join(", ", post.getAmenities()) : "Kh√¥ng r√µ"
            );

            return prompt;
        }).flatMap(prompt -> useMemory ? chat(prompt) : chatSingle(prompt));
    }


}
